#include <iostream>
#include <vector>
#include <queue>
#include <list>
#include <algorithm>

template <typename K, typename V>
struct KeyValuePair
{
    K key;
    V value;

    KeyValuePair(const KeyValuePair<K,V>& key, const KeyValuePair<K,V>& value) : key(key), value(value) {}
};

template <typename V>
class Graph
{
public:
    using EdgeList = KeyValuePair<V, std::list<V>>;

    std::vector<V> vertices() const
    {
        std::vector<V> result;

        for(const EdgeList& e : data)
        {
            result.push_back(e.key);
        }

        return result;
    }

    std::list<V> successors(const V& u) const
    {
        for(const EdgeList& e : data)
        {
            if(e.key == u)
            {
                return e.value;
            }
        }

        return std::list<V>();
    }

    void print() const
    {
        for(const EdgeList& e : data)
        {
            std::cout << e.key << " -> ";
            for(const V& v : e.value)
            {
                std::cout << v << " ";
            }
            std::cout << '\n';
        }
    }

    bool has_edge(const V& u, const V& v) const
    {
        for(const V& s :  successors(u))
        {
            if(s == v)
            {
                return true;
            }
        }
    }

    void add_vertex(const V& u) 
    {
        data.push_back(EdgeList(u, std::list<V>()));
    }

    void add_edge(const V& u, const V& v)
    {
        for(EdgeList& e : data)
        {
            if(e.key == u)
            {
                e.value.push_back(v);
            }
        }
    }
private:
    std::vector<EdgeList> data;
};

//zad 3
template <typename V>
std::pair<unsigned, unsigned> degree(const Graph<V>& graph, const V& u)
{
    unsigned out_degree = graph.successors(u).size();
    unsigned in_degree = 0;

    for(const V& v : graph.vertices())
    {
        for(const V& w : graph.successors(v))
        {
            if(w == u)
            {
                ++in_degree;
            }
        }
    }

    return std::make_pair(in_degree, out_degree);
}

//zad 4
template <typename V>
Graph<V> invert(const Graph<V>& graph)
{
    Graph<V> result; 

    for(const V& v : graph.vertices())
    {
        result.add_vertex(v);
    }

    for(const V& v : graph.vertices())
    {
        for(const V& u : graph.vertices(v))
        {
            result.add_edge(u, v);
        }
    }

    return result;
}



//zad 6
template <typename V>
void dfs(const Graph<V>& graph, std::vector<V>& path, const V& u)
{
    path.push_back(u);

    for(const V& v : graph.successors(u))
    {
        if(std::find(path.begin(), path.end(), v) == path.end) 
        {
            dfs(graph, path, v);
        }
        
    }
}

template <typename V>
std::vector<V> dfs(const Graph<V>& graph)
{
    std::vector<V> path;

    for(const V& u : graph.vertices())
    {
        if(std::find(path.begin(), path.end(), u) == path.end())
        {
            dfs(graph, path, u);
        }
    }
}

//Ако на контролно ни дадат задача за обхождане на свързани компоненти - DFS!

//zad 7 - BFS заема повече памет
template <typename V>
void bfs(const Graph<V>& graph, std::vector<V>& path, const V& u)
{
    std::queue<V> queue;
    queue.push(u);

    while(!queue.empty())
    {
        V current = queue.front();
        queue.pop();


        path.push_back(current);

        for(const V& v : graph.successors(current))
        {
            if(std::find(path.begin(), path.end(), u) == path.end())
            {
                queue.push(v);
            }
        }
    }
}


template <typename V>
std::vector<V> bfs(const Graph<V>& graph)
{
    std::vector<V> visited;

    for(const V& u : graph.vertices())
    {
        if(std::find(path.begin(), path.end(), u) == path.end())
        {
            bfs(graph, visited, u);
        }
    }

    return visited;
}



int main()
{
    Graph<int> graph;
    graph.add_vertex(1);
    graph.add_vertex(2);
    graph.add_vertex(3);
    graph.add_vertex(4);
    graph.add_vertex(5);

    graph.add_edge(1, 2);
    graph.add_edge(1, 3);
    graph.add_edge(1, 4);

    graph.add_edge(2, 1);
    graph.add_edge(2, 3);
    graph.add_edge(2, 5);

    graph.add_edge(3, 1);
    graph.add_edge(3, 2);
    graph.add_edge(3, 4);
    graph.add_edge(3, 5);

    graph.add_edge(4, 1);
    graph.add_edge(4, 3);
    graph.add_edge(4, 5);

    graph.add_edge(5, 2);
    graph.add_edge(5, 3);
    graph.add_edge(5, 4);

    graph.print();
    std::cout << '\n';

    /*
    1 - 2 3 4 
    2 - 1 3 5 
    3 - 1 2 4 5 
    4 - 1 3 5 
    5 - 2 3 4 
    */

    Graph<int> oriented_graph;
    oriented_graph.add_vertex(1);
    oriented_graph.add_vertex(2);
    oriented_graph.add_vertex(3);
    oriented_graph.add_vertex(4);
    oriented_graph.add_vertex(5);

    oriented_graph.add_edge(1, 2);
    oriented_graph.add_edge(1, 3);
    oriented_graph.add_edge(1, 4);

    oriented_graph.add_edge(2, 3);
    oriented_graph.add_edge(2, 5);

    oriented_graph.add_edge(3, 4);
    oriented_graph.add_edge(3, 5);

    oriented_graph.add_edge(5, 2);
    oriented_graph.add_edge(5, 4);

    oriented_graph.print();

    /*
    1 - 2 3 4 
    2 - 3 5 
    3 - 4 5 
    4 - 
    5 - 2 4 
    */

    for (int v : bfs(graph)) 
    {
        std::cout << v << ' ';
    }
    std::cout << '\n';
    return 0;
}
